#!/usr/bin/perl
use strict;
use warnings;

use Music::Client::MPD;
use Music::LastFM;
use Data::Dumper;
use List::Util qw(min);

my $lfm = Music::LastFM->new(
    config_filename => 't/options.conf',
    username        => 'riemann42'
);

my $client = Music::Client::MPD->new(
    {   host => 'themusic',
        host => "themusic",
        port => "6600",
        root => "/mnt/media/music/MP3s",
    }
);

my $current_status;
my $running_time;
my $last_running_time;
my $last_update_time;
my $last_played_time;
my $current_track;

sub reset_status {
    print STDERR "\nReset status\n";
    $running_time      = 0;
    $last_running_time = 0;
    $last_update_time  = 0;
    $last_played_time  = time;
    $current_track     = undef;
}

sub update_info {
    my $new_status = $client->get_info();
    my $time       = time;
    if ( $new_status->{state} eq 'play' ) {
        ( $new_status->{so_far}, $new_status->{song_duration} ) =
            $new_status->{'time'}
            ? ( split( /:/, $new_status->{'time'} ) )
            : ( 0, 0 );

        if ((defined $current_status) && ( !$new_status->{Id} == $current_status->{Id}
        )) {
            change_song();
        }
        if ( !defined $current_track ) {
            $current_track = $lfm->new_track(
                name   => $new_status->{Title},
                artist => $new_status->{Artist},

                #album  => {
                #    artist => $new_status->{Artist},
                #    name   => $new_status->{Album}
                #},
                last_played => $last_played_time
            );
            print STDERR "\n", $current_track->last_played->epoch, "\n";
            $lfm->scrobble->now_playing( track => $current_track );
        }

        if ( !defined $last_running_time ) {
            $last_running_time = $new_status->{so_far};
        }

        my $run_since_update = ( $new_status->{so_far} - $running_time );
        my $time_since_update =
            ( $time - $last_update_time ) + 5;    # adding 1 for rounding
        if (   ( $run_since_update > 0 )
            && ( $run_since_update <= $time_since_update ) ) {
            $running_time += $run_since_update;
        }
        elsif (
            ( $run_since_update < -240 )
            || ( $run_since_update
                < ( -1 * ( $new_status->{song_duration} / 2 ) ) )
            ) {

            #long skip back
            change_song();
        }
        $last_running_time = $new_status->{so_far};
        $last_update_time  = $time;
    }
    elsif (( $new_status->{state} eq 'stop' )
        && ($running_time) ) {
        change_song();
    }
    $current_status = $new_status;
}

sub change_song {
    my $self = shift;
    if ($current_track) {
        if ( $current_status->{song_duration} ) {
            my $needed_time =
                min( 240, $current_status->{song_duration} / 2 );
            if (   ( $running_time >= $needed_time )
                && ( $current_status->{song_duration} >= 30 ) ) {
                scrobble();
            }
        }
    }
    reset_status();
}

sub scrobble {
    print "Will Scrobble: ", Dumper($current_status);
    $lfm->scrobble->add_track( track => $current_track );
}

sub monitor_mpd {
    while (1) {
        update_info();
        print STDERR $current_status->{state}, " ",
            $current_status->{time}, " ", $running_time, " ",
            $current_status->{song_duration}, "\r";
        sleep 1;
        $lfm->scrobble->process_scrobble_queue();
    }
}

reset_status();
monitor_mpd();

